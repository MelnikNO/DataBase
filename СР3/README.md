# Инвариантная часть
## Задание 3.1: Реализация реляционной модели данных
В предметной области, предложенной преподавателем, реализовать реляционную модель данных. Спроектированная таблица должна отображать связи между сущностями, потенциальные ключи, условия проверки атрибутов.

В данном задании необходимо обратиться к следующим документам:

* Описание предметной области находится в приложении.

* Задания.

## Решение
**Задания:**
1.	Определите потенциальные ключи для каждого из отношений. Если для каких-то отношений таких ключей окажется несколько, выберите один из них на роль первичного (PK), а остальные пометьте альтернативными (AK).
**Решение:** Таблицы с начальными данными были разбавлены после прочтения описания к заданию

 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/1.png)
 
 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/2.png)

 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/3.png)

 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/4.png)

 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/5.png)

  ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/6.png)

   ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/7.png)
 
 
2.	Определите, какие из атрибутов отношений являются обязательными, т.е. не допускают наличие неизвестных значений. Пометьте такие атрибуты как NOT NULL.
   
**Решение:** Это показано в номере 1

3.	Определите условия проверки значений для атрибутов (где возможно и, на ваш взгляд, имеет смысл). Условия требуется записать в виде логического выражения (предиката), в левой части которого указано имя атрибута, а в правой – значения, с которыми требуется произвести сравнение. Допускается использование реляционных (>, =, <=, =, !=) и логических (AND, OR) операторов, а также оператора LIKE в том синтаксисе, с которым вы познакомились при выполнении лабораторной работы второй недели.

Для таблицы «ИГРА»:
 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/8.png)

Для таблицы «КЛИЕНТ»:

 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/9.png)
 
Для таблицы «ЗАКАЗ»:
 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/10.png)
 
Для таблицы «СОТРУДНИК»:
  ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/11.png)

4.	Определите связи между отношениями.

**Решение:**

•	ИГРА (1) → ЗАКАЗ (N)

•	КЛИЕНТ (1) → ЗАКАЗ (N)

•	СОТРУДНИК (1) → ЗАКАЗ (N)

5.	Установите связь между отношениями, добавив атрибуты первичного ключа главного отношения (того, к которому относится слово ОДИН) в состав дочернего (того, к которому относится слово МНОГО) и отметив их как внешний ключ (FK).

**Решение:**
  ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/12.png)

 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/13.png)
 

6.	Проверьте добавленные при установке связей атрибуты на обязательность, пометьте их как NOT NULL, если это требуется. Проверьте, не появились ли новые потенциальные ключи в результате добавления новых атрибутов.

**Решение:**
Если изменить их на необязательные
 ![alt text](https://github.com/MelnikNO/DataBase/blob/main/screen/СР3/14.png)
 
Никаких новых потенциальных ключей не появилось

7.	Ответьте на вопрос (письменно): Допустим, что каждый сотрудник может обработать только один заказ (после чего его увольняют ). В этом случае, связь между отношениями ЗАКАЗ и СОТРУДНИК трансформируется в один-к-одному. Что нужно будет сделать дополнительно для поддержки этой связи? Что может помешать указать одного и того же сотрудника в отношении ЗАКАЗ, ответственным за обработку нескольких разных заказов?

**Решение:**

Для поддержки связи один-к-одному между отношениями ЗАКАЗ и СОТРУДНИК, где каждый сотрудник может обработать только один заказ, необходимо выполнить несколько шагов:

•	В таблице ЗАКАЗ должно быть установлено уникальное ограничение на поле, которое ссылается на Таб_номер. Это гарантирует, что каждый сотрудник может быть назначен только на один заказ.

•	Необходимо внедрить логику, которая автоматически увольняет сотрудника после завершения обработки заказа. Это может быть реализовано через триггеры в базе данных или через код приложения, который будет следить за статусом заказа и увольнять сотрудника по его завершении.

•	Важно также обеспечить правильное обновление статусов заказов и сотрудников. После обработки заказа статус заказа должен измениться, а статус сотрудника — на "уволен".

Что может помешать указать одного и того же сотрудника ответственным за обработку нескольких заказов:

•	Если не будет установлено уникальное ограничение, то система не сможет предотвратить назначение одного и того же сотрудника на несколько заказов, что нарушит логику один-к-одному.

•	Если логика увольнения или обновления статусов реализована неверно, это может привести к ситуации, когда сотрудник остается активным и может быть назначен на новый заказ, несмотря на то, что он уже должен был быть уволен.

•	Если несколько процессов одновременно пытаются назначить одного и того же сотрудника на разные заказы, это может привести к конфликтам и ошибкам в данных.


---

# Вариативная часть (выбирается одно задание на выбор)
## Задание 3.2: Анализ БД на избыточность
Проанализировать информацию по избыточности баз данных и привести примеры неверного логического проектирования. Предложить алгоритм решения (по устранению) недостатков логической структуры.

## Решение

Избыточность полезна, например, для резервного копирования. Но она также нежелательна:

•	Увеличивает объем хранимых данных.

•	Затрудняет обновление данных.

•	Снижает производительность: запросы к базе данных могут занимать больше времени, так как требуется обработка большего объема данных.

•	Увеличивает риск аномалий при вставке, удалении и обновлении данных.

**Примеры неверного логического проектирования:**

Предположим, у нас есть небольшая библиотека. Изначально мы хотим хранить информацию о книгах и авторах в одной таблице.

**Исходная, ненормализованная таблица «КнигиИАвторы»**

| ID_Книги    | НазваниеКниги | АвторИмя | АвторФамилия | АвторСтрана | ЖанрКниги |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 1 |  “Мастер и Маргарита” | Михаил | Булгаков | СССР | Роман| 
| 2 | “Собачье сердце” | Михаил |Булгаков | СССР| Сатира |
| 3 |	“1984” |	Джордж |	Оруэлл |	Англия |	Антиутопия |
| 4 |	“Скотный двор” |	Джордж |	Оруэлл |	Англия |	Сатира |
| 5 |	“Война и мир” |	Лев |	Толстой |	Россия |	Роман |

**Проблемы:**

•	**Избыточность информации об авторе:** Имя, фамилия и страна автора повторяются для каждой книги этого автора. В примере с Булгаковым и Оруэллом это видно очень четко.

•	**Проблемы с обновлением:** Если автор сменит страну (например, переедет), придется обновлять все записи книг этого автора.

•	**Риск несогласованности:** Возможно случайное внесение разных вариантов имени/фамилии одного и того же автора (например, “Михаил Булгаков” и “М. Булгаков”).

•	**Увеличение объема хранения:** Дублирование информации занимает лишнее место.

•	**Аномалия вставки:** Невозможно добавить информацию об авторе, пока у него не будет написана книга.

•	**Аномалия удаления:** Удаление последней книги автора приведет к потере информации об авторе.


**Алгоритм решения (устранения) недостатков логической структуры (нормализация):**

Алгоритм решения проблем избыточности в базах данных обычно сводится к процессу, называемому нормализацией. Нормализация — это процесс организации данных в базе данных для уменьшения избыточности и повышения целостности данных. Он включает в себя разделение больших таблиц на меньшие и определение связей между ними. Существуют различные нормальные формы, каждая из которых устраняет определенный вид избыточности.

1.	**Определите атрибуты (поля):** составьте список всех атрибутов, которые необходимо хранить в базе данных.
2.	**Определите функциональные зависимости:** установите, какие атрибуты функционально зависят от других атрибутов. Атрибут B функционально зависит от атрибута A, если каждое значение A однозначно определяет значение B.
3.	**Первая Нормальная Форма (1NF):**

o	Устраните повторяющиеся группы атрибутов.

o	Создайте отдельную таблицу для каждой группы связанных атрибутов.

o	Определите первичный ключ для каждой таблицы.

Пример: Таблица «КнигиИАвторы» уже находится в 1NF, так как в ней нет повторяющихся групп. Каждое поле содержит атомарное значение.

4.	**Вторая Нормальная Форма (2NF):**

o	Таблица должна быть в 1NF.

o	Устраните неполную зависимость от первичного ключа. Атрибуты, зависящие только от части составного первичного ключа, должны быть вынесены в отдельную таблицу.

Пример: Разделяем информацию о книгах и авторах в отдельные таблицы.

:small_blue_diamond: Авторы: (ID_Авторы, АвторИмя, АвторФамилия, АвторСтрана)

:small_blue_diamond:	Книги: (ID_Книги; НазваниеКниги; ID_Автора; ЖанрКниги)

5.	**Третья Нормальная Форма (3NF):**

o	Таблица должна быть в 2NF.

o	Устраните транзитивную зависимость. Атрибуты, зависящие от неключевого атрибута, должны быть вынесены в отдельную таблицу.

Пример: если у нас, к примеру, есть дополнительное поле в таблице Книги - ОписаниеЖанра, которое зависит только от ЖанрКниги, тогда можно выделить Жанры в отдельную таблицу:

:small_blue_diamond:	Жанры: (ID_Жанра, ЖанрКниги, ОписаниеЖанра)

:small_blue_diamond: Авторы: (ID_Автора, АвторИмя, АвторФамилия, АвторСтрана)

:small_blue_diamond: Книги: (ID_Книги, НазваниеКниги, ID_Автора, ID_Жанра)

6.	**Четвертая нормальная форма (4NF) и пятая нормальная форма (5NF):** эти нормальные формы рассматривают более сложные случаи зависимостей, такие как многозначные и составные зависимости. Они используются реже, чем 1NF, 2NF и 3NF.

